import {
  basicSetup,
  diagnosticCount,
  forceLinting,
  indentWithTab,
  lintGutter,
  linter,
  minimalSetup
} from "./chunk-PDFECE42.js";
import {
  indentUnit
} from "./chunk-UGY5IE7A.js";
import {
  Compartment,
  EditorSelection,
  EditorState,
  EditorView,
  StateEffect,
  keymap,
  placeholder
} from "./chunk-JWQJHWJ5.js";
import {
  isVue2
} from "./chunk-HYZ2CRGS.js";
import {
  computed,
  defineComponent,
  h,
  nextTick,
  onMounted,
  onUnmounted,
  ref,
  shallowRef,
  watch
} from "./chunk-S7ZBDJCF.js";
import "./chunk-5WWUZCGV.js";

// node_modules/vue-codemirror6/dist/index.es.js
var me = {
  version: "1.3.17",
  date: "2025-06-02T14:16:10.878Z"
};
var le = (e) => e ? Object.entries(e).reduce((i, [l, u]) => (l = l.charAt(0).toUpperCase() + l.slice(1), l = `on${l}`, { ...i, [l]: u }), {}) : {};
function B(e, i = {}, l) {
  if (isVue2)
    return h(e, i, l);
  const { props: u, domProps: t, on: d, ...f } = i, m = d ? le(d) : {};
  return h(
    e,
    { ...f, ...u, ...t, ...m },
    l
  );
}
var ie = (e) => typeof e == "function" ? e() : e;
var oe = defineComponent({
  /** Component Name */
  name: "CodeMirror",
  /** Model Definition */
  model: {
    prop: "modelValue",
    event: "update:modelValue"
  },
  /** Props Definition */
  props: {
    /** Model value */
    modelValue: {
      type: String,
      default: ""
    },
    /**
     * Theme
     *
     * @see {@link https://codemirror.net/docs/ref/#view.EditorView^theme}
     */
    theme: {
      type: Object,
      default: () => ({})
    },
    /** Dark Mode */
    dark: {
      type: Boolean,
      default: false
    },
    /**
     * Use Basic Setup
     *
     * @see {@link https://codemirror.net/docs/ref/#codemirror.basicSetup}
     */
    basic: {
      type: Boolean,
      default: false
    },
    /**
     * Use Minimal Setup (The basic setting has priority.)
     *
     * @see {@link https://codemirror.net/docs/ref/#codemirror.minimalSetup}
     */
    minimal: {
      type: Boolean,
      default: false
    },
    /**
     * Placeholder
     *
     * @see {@link https://codemirror.net/docs/ref/#view.placeholder}
     */
    placeholder: {
      type: String,
      default: void 0
    },
    /**
     * Line wrapping
     *
     * An extension that enables line wrapping in the editor (by setting CSS white-space to pre-wrap in the content).
     *
     * @see {@link https://codemirror.net/docs/ref/#view.EditorView%5ElineWrapping}
     */
    wrap: {
      type: Boolean,
      default: false
    },
    /**
     * Allow tab key indent.
     *
     * @see {@link https://codemirror.net/examples/tab/}
     */
    tab: {
      type: Boolean,
      default: false
    },
    /**
     * Tab character
     */
    indentUnit: {
      type: String,
      default: void 0
    },
    /**
     * Allow Multiple Selection.
     *
     * @see {@link https://codemirror.net/docs/ref/#state.EditorState^allowMultipleSelections}
     */
    allowMultipleSelections: {
      type: Boolean,
      default: false
    },
    /**
     * Tab size
     *
     * @see {@link https://codemirror.net/docs/ref/#state.EditorState^tabSize}
     */
    tabSize: {
      type: Number,
      default: void 0
    },
    /**
     * Set line break (separetor) char.
     *
     * @see {@link https://codemirror.net/docs/ref/#state.EditorState^lineSeparator}
     */
    lineSeparator: {
      type: String,
      default: void 0
    },
    /**
     * Readonly
     *
     * @see {@link https://codemirror.net/docs/ref/#state.EditorState^readOnly}
     */
    readonly: {
      type: Boolean,
      default: false
    },
    /**
     * Disable input.
     *
     * This is the reversed value of the CodeMirror editable.
     * Similar to `readonly`, but setting this value to true disables dragging.
     *
     * @see {@link https://codemirror.net/docs/ref/#view.EditorView^editable}
     */
    disabled: {
      type: Boolean,
      default: false
    },
    /**
     * Additional Extension
     *
     * @see {@link https://codemirror.net/docs/ref/#state.Extension}
     */
    extensions: {
      type: Array,
      default: () => []
    },
    /**
     * Language Phreses
     *
     * @see {@link https://codemirror.net/examples/translate/}
     */
    phrases: {
      type: Object,
      default: void 0
    },
    /**
     * CodeMirror Language
     *
     * @see {@link https://codemirror.net/docs/ref/#language}
     */
    lang: {
      type: Object,
      default: void 0
    },
    /**
     * CodeMirror Linter
     *
     * @see {@link https://codemirror.net/docs/ref/#lint.linter}
     */
    linter: {
      type: Function,
      default: void 0
    },
    /**
     * Linter Config
     *
     * @see {@link https://codemirror.net/docs/ref/#lint.linter^config}
     */
    linterConfig: {
      type: Object,
      default: () => ({})
    },
    /**
     * Forces any linters configured to run when the editor is idle to run right away.
     *
     * @see {@link https://codemirror.net/docs/ref/#lint.forceLinting}
     */
    forceLinting: {
      type: Boolean,
      default: false
    },
    /**
     * Show Linter Gutter
     *
     * An area to ðŸ”´ the lines with errors will be displayed.
     * This feature is not enabled if `linter` is not specified.
     *
     * @see {@link https://codemirror.net/docs/ref/#lint.lintGutter}
     */
    gutter: {
      type: Boolean,
      default: false
    },
    /**
     * Gutter Config
     *
     * @see {@link https://codemirror.net/docs/ref/#lint.lintGutter^config}
     */
    gutterConfig: {
      type: Object,
      default: void 0
    },
    /**
     * Using tag
     */
    tag: {
      type: String,
      default: "div"
    },
    /**
     * Allows an external update to scroll the form.
     * @see {@link https://codemirror.net/docs/ref/#state.TransactionSpec.scrollIntoView}
     */
    scrollIntoView: {
      type: Boolean,
      default: true
    }
  },
  /** Emits */
  emits: {
    /** Model Update */
    "update:modelValue": (e = "") => true,
    /** CodeMirror ViewUpdate */
    update: (e) => true,
    /** CodeMirror onReady */
    ready: (e) => true,
    /** CodeMirror onFocus */
    focus: (e) => true,
    /** State Changed */
    change: (e) => true,
    /** CodeMirror onDestroy */
    destroy: () => true
  },
  /**
   * Setup
   *
   * @param props  - Props
   * @param context - Context
   */
  setup(e, i) {
    const l = ref(), u = ref(e.modelValue), t = shallowRef(new EditorView()), d = computed({
      get: () => t.value.hasFocus,
      set: (a) => {
        a && t.value.focus();
      }
    }), f = computed({
      get: () => t.value.state.selection,
      set: (a) => t.value.dispatch({ selection: a })
    }), m = computed({
      get: () => t.value.state.selection.main.head,
      set: (a) => t.value.dispatch({ selection: { anchor: a } })
    }), M = computed(
      {
        get: () => t.value.state.toJSON(),
        set: (a) => t.value.setState(EditorState.fromJSON(a))
      }
    ), S = ref(0), h2 = ref(0), g = computed(() => {
      const a = new Compartment(), n = new Compartment();
      if (e.basic && e.minimal)
        throw new Error(
          "[Vue CodeMirror] Both basic and minimal cannot be specified."
        );
      return [
        // Toggle basic setup
        e.basic && !e.minimal ? basicSetup : void 0,
        // Toggle minimal setup
        e.minimal && !e.basic ? minimalSetup : void 0,
        // ViewUpdate event listener
        EditorView.updateListener.of((o) => {
          var _a;
          i.emit("focus", t.value.hasFocus), S.value = (_a = t.value.state.doc) == null ? void 0 : _a.length, !(o.changes.empty || !o.docChanged) && (e.linter && (e.forceLinting && forceLinting(t.value), h2.value = e.linter(t.value).length), i.emit("update", o));
        }),
        // Toggle light/dark mode.
        EditorView.theme(e.theme, { dark: e.dark }),
        // Toggle line wrapping
        e.wrap ? EditorView.lineWrapping : void 0,
        // Indent with tab
        e.tab ? keymap.of([indentWithTab]) : void 0,
        // Tab character
        e.indentUnit ? indentUnit.of(e.indentUnit) : void 0,
        // Allow Multiple Selections
        EditorState.allowMultipleSelections.of(e.allowMultipleSelections),
        // Indent tab size
        e.tabSize ? n.of(EditorState.tabSize.of(e.tabSize)) : void 0,
        // locale settings
        e.phrases ? EditorState.phrases.of(e.phrases) : void 0,
        // Readonly option
        EditorState.readOnly.of(e.readonly),
        // Editable option
        EditorView.editable.of(!e.disabled),
        // Set Line break char
        e.lineSeparator ? EditorState.lineSeparator.of(e.lineSeparator) : void 0,
        // Lang
        e.lang ? a.of(e.lang) : void 0,
        // Append Linter settings
        e.linter ? linter(e.linter, e.linterConfig) : void 0,
        // Show ðŸ”´ to error line when linter enabled.
        e.linter && e.gutter ? lintGutter(e.gutterConfig) : void 0,
        // Placeholder
        e.placeholder ? placeholder(e.placeholder) : void 0,
        // Append Extensions
        ...e.extensions
      ].filter((o) => !!o);
    });
    watch(
      g,
      (a) => {
        var _a;
        return (_a = t.value) == null ? void 0 : _a.dispatch({ effects: StateEffect.reconfigure.of(a) });
      },
      { immediate: true }
    ), watch(
      () => e.modelValue,
      async (a) => {
        if (t.value.composing || // IME fix
        t.value.state.doc.toJSON().join(e.lineSeparator ?? `
`) === a)
          return;
        const n = !t.value.state.selection.ranges.every(
          (o) => o.anchor < a.length && o.head < a.length
        );
        t.value.dispatch({
          changes: { from: 0, to: t.value.state.doc.length, insert: a },
          selection: n ? { anchor: 0, head: 0 } : t.value.state.selection,
          scrollIntoView: e.scrollIntoView
        });
      },
      { immediate: true }
    ), onMounted(async () => {
      let a = u.value;
      l.value && (l.value.childNodes[0] && (u.value !== "" && console.warn(
        "[CodeMirror.vue] The <code-mirror> tag contains child elements that overwrite the `v-model` values."
      ), a = l.value.childNodes[0].innerText.trim()), t.value = new EditorView({
        parent: l.value,
        state: EditorState.create({ doc: a, extensions: g.value }),
        dispatch: (n) => {
          t.value.update([n]), !(n.changes.empty || !n.docChanged) && (i.emit("update:modelValue", n.state.doc.toString()), i.emit("change", n.state));
        }
      }), await nextTick(), i.emit("ready", {
        view: t.value,
        state: t.value.state,
        container: l.value
      }));
    }), onUnmounted(() => {
      t.value.destroy(), i.emit("destroy");
    });
    const $ = () => {
      !e.linter || !t.value || (e.forceLinting && forceLinting(t.value), h2.value = diagnosticCount(t.value.state));
    }, j = () => {
      var _a, _b;
      (_a = t.value) == null ? void 0 : _a.dispatch({
        effects: StateEffect.reconfigure.of([])
      }), (_b = t.value) == null ? void 0 : _b.dispatch({
        effects: StateEffect.appendConfig.of(g.value)
      });
    }, x = (a, n) => t.value.state.sliceDoc(a, n), _ = (a) => t.value.state.doc.line(a + 1).text, L = () => t.value.state.doc.lines, N = () => t.value.state.selection.main.head, U = () => {
      let a;
      return (a = t.value.state.selection.ranges) !== null && a !== void 0 ? a : [];
    }, z = () => {
      let a;
      return (a = t.value.state.sliceDoc(
        t.value.state.selection.main.from,
        t.value.state.selection.main.to
      )) !== null && a !== void 0 ? a : "";
    }, E = () => {
      const a = t.value.state;
      return a ? a.selection.ranges.map(
        (n) => a.sliceDoc(n.from, n.to)
      ) : [];
    }, R = () => t.value.state.selection.ranges.some(
      (a) => !a.empty
    ), T = (a, n, o) => t.value.dispatch({
      changes: { from: n, to: o, insert: a }
    }), D = (a) => t.value.dispatch(t.value.state.replaceSelection(a)), F = (a) => t.value.dispatch({ selection: { anchor: a } }), I = (a, n) => t.value.dispatch({ selection: { anchor: a, head: n } }), J = (a, n) => t.value.dispatch({
      selection: EditorSelection.create(a, n)
    }), A = (a) => t.value.dispatch({
      selection: EditorSelection.create(
        f.value.ranges.map((n) => n.extend(a(n)))
      )
    }), p = {
      editor: l,
      view: t,
      cursor: m,
      selection: f,
      focus: d,
      length: S,
      json: M,
      diagnosticCount: h2,
      dom: t.value.contentDOM,
      lint: $,
      forceReconfigure: j,
      // Bellow is CodeMirror5's function
      getRange: x,
      getLine: _,
      lineCount: L,
      getCursor: N,
      listSelections: U,
      getSelection: z,
      getSelections: E,
      somethingSelected: R,
      replaceRange: T,
      replaceSelection: D,
      setCursor: F,
      setSelection: I,
      setSelections: J,
      extendSelectionsBy: A
    };
    return i.expose(p), p;
  },
  render() {
    return B(
      this.$props.tag,
      {
        ref: "editor",
        class: "vue-codemirror"
      },
      this.$slots.default ? (
        // Hide original content
        B(
          "aside",
          { style: "display: none;", "aria-hidden": "true" },
          ie(this.$slots.default)
        )
      ) : void 0
    );
  }
});
var he = (e) => e.component("CodeMirror", oe);
export {
  me as Meta,
  oe as default,
  he as install
};
/*! Bundled license information:

vue-codemirror6/dist/index.es.js:
  (**
   * vue-codemirror6
   *
   * @description CodeMirror6 Component for vue2 and vue3.
   * @author Logue <logue@hotmail.co.jp>
   * @copyright 2022-2025 By Masashi Yoshikawa All rights reserved.
   * @license MIT
   * @version 1.3.17
   * @see {@link https://github.com/logue/vue-codemirror6}
   *)
*/
//# sourceMappingURL=vue-codemirror6.js.map
